# -*- coding: utf-8 -*-
"""Card Elimination Game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L73E7jdcTwHX33KkeqE1y6iCD4aKsj_G
"""

import numpy as np
import pandas as pd
from collections import Counter

from itertools import permutations

class Initial_Layout:


  '''
  This class is mainly used for intializing a layout with specific requirement
  (without explicitly giving the layout)

  '''

  def __init__(self, colors, numbers, layout):
    '''
    colors: a list of all colors we want
    numbers: a list of number of cards for each corresponding color we specified earlier
    layout: a list with two integers, with the first integer specifying the number of rows and the second integer for the column
    '''
    self.colors = colors
    self.numbers = numbers
    self.row = layout[0]
    self.column = layout[1]
    self.layout = self.generate_layout()
    self.layout_copy = self.layout.copy()
    self.color_dict = dict()

    for color in self.colors:
      self.color_dict[color] = 0
    self.intuitive_sequence = self.find_intuitive_sequence()

  def generate_layout(self):
    '''
    colors: a list of strings indicating the colors we need
    numbers: a list corresponding to how many numbers we want for each color
            corresponding to the first input
    layout: a list with the first element indicating how many rows we want 'ele1",
            and the second element indicating how many cards we want for each row 'ele2',
            ele1 * ele2 should match up with the sum of numbers in 'number'
    '''

    assert len(self.colors) == len(self.numbers)
    assert self.row * self.column == sum(self.numbers)
    assert all([number % 3 for number in self.numbers]) == 0

    np.random.seed(42)

    card_list = np.empty((0, 2))
    for color, number in zip(self.colors, self.numbers):
      for i in np.arange(number):
        card_list = np.append(card_list, np.array([[color, i]]), axis = 0)
    np.random.shuffle(card_list)
    return card_list.reshape((self.row, self.column, 2)).tolist()

  def generate_mdp(self):

    '''
    calling the MDP class to solve for optimal
    '''

    # keep track of colors of cards on the deck in a dictionary
    color_dict = dict()
    for color in self.colors:
      color_dict[color] = 0

    # keep track of current length of the deck
    current_deck_length = 0

    # keep track of maximum_length from the beginning
    maximum_deck_length = 0

    return Layout(self.layout, color_dict, current_deck_length, maximum_deck_length)


  def max_deck_length(self, drawing):
    '''
    the maximum number of deck length happening in the entire drawing process
    '''
    return max(self.deck_length(drawing))

  def deck_length(self, one_drawing):
    '''
    a list consisting of the deck length after each card draw for one sequence of drawing
    '''
    curr_length = 0
    deck_length_list = []
    deck = []
    for card in one_drawing:
      if self.no_elimination(deck, card):
        deck += card
        curr_length += 1
      else:
        deck = self.shorten_deck(deck, card)
        curr_length -= 2
      deck_length_list.append(curr_length)
    return deck_length_list

  def no_elimination(self, deck, card):
    '''
    a boolean value to judge if elimination would happen
    '''
    card_types = [i[0] for i in deck] + [card[0]]
    x = Counter(card_types)
    return all([i < 3 for i in x.values()])


  def shorten_deck(self, deck, card):
    '''
    shorten the deck size if card has the same color as two cards in the deck
    '''

    card_types = [i[0] for i in deck] + [card[0]]
    x = Counter(card_types)
    for i in x.items():
      if i[1] == 3:
        alphabet = i[0]
    deck = [i for i in deck if i[0] != alphabet]
    return deck

  def all_drawing_possibilities_alternative(self):
    '''
    layout: the layout return by generate_layout function, contain a list of list
    '''
    assert self.row * self.column <= 12 # currently does not work fo BIG layout

    layout = self.layout.copy()
    layout = [i for i in layout if len(i) != 0]
    if not layout:
      return [[]]
    result = []
    for i in np.arange(len(layout)):
      new_layout = layout.copy()
      first = [new_layout[i][0]]
      new_layout[i] = new_layout[i][1:]
      result += [first + j for j in self.all_drawing_possibilities()]
    return result

  def find_layout_dictionary(self):
    '''
    return the dictionary containing the position of elements
    '''
    layout = self.layout.copy()
    draw_dict = {}
    for i in range(len(layout[0])):
      for j in range(len(layout)):
        letter = layout[j][i][0]
        if layout[j][i][0] not in draw_dict.keys():
          draw_dict[letter] = [[j, i]]
        else:
          draw_dict[letter].append([j, i])
    return draw_dict


  def find_intuitive_sequence(self):
    '''
    Finding the intuitive drawing for a normal/intuitive/good-performing player

    Here is an explaination of how this function works:

    (1) find the color of the card with its three cards lying in the shallowest layers
        here I define "shallow" being a column wise compared to the top layer where we can directly draw from
    (2) draw all the cards until I have all the three cards of the color we found in step (1), perform an elimination
    (3) continue with the first two steps until all the cards has been drawn, taking into account of the cards we
        put on the deck as a "side effect" of eliminating the step (1) color (i.e. if we have many cards of one color in hand
        then maybe we would choose to eliminate that color first, though cards maybe hidden deep in our current layout)
    '''

    if all(inner_lst == [] for inner_lst in self.layout_copy):
      return []

    simulation_color_dict = dict()
    for color in self.colors:
      simulation_color_dict[color] = []
    position_dict = dict()
    for color in self.colors:
      position_dict[color] = []

    for j in np.arange(self.column):
      curr_color_dict = dict()
      for color in self.colors:
        curr_color_dict[color] = 0
      for i in np.arange(self.row):
        try:
          curr_color = self.layout_copy[i][j][0]
        except:
          continue
        curr_color_dict[curr_color] += 1
        position_dict[curr_color] += [[i, j]]
      for color in self.colors:
        simulation_color_dict[color] += [curr_color_dict[color]]


    # positional_idx = 0
    # summation_dict = self.color_dict.copy()
    # color_lst = []
    # while True:
    #   for color in self.colors:
    #     summation_dict[color] += simulation_color_dict[color][positional_idx]
    #     if summation_dict[color] >= 3:
    #       color_lst += color


    trunc_result = {}

    for color in self.colors:
      result = []
      position = position_dict[color][:3]
      position.sort()
      current_first_elem = None
      current_max_second_elem = None
      for pair in position:
          first_elem, second_elem = pair
          if current_first_elem is None:
              current_first_elem = first_elem
              current_max_second_elem = second_elem
          elif first_elem == current_first_elem:
              current_max_second_elem = max(current_max_second_elem, second_elem)
          else:
              result.append([current_first_elem, current_max_second_elem])
              current_first_elem = first_elem
              current_max_second_elem = second_elem

      # Add the last pair to the result
      result.append([current_first_elem, current_max_second_elem])
      if current_first_elem != None:
        trunc_result[color] = result

    # print(trunc_result)
    appended_elements_num = {}
    for color in trunc_result.keys():
      appended_elements_num[color] = 0
      for row, column in trunc_result[color]:
        # print(appended_elements_num.get(color))
        appended_elements_num[color] = appended_elements_num.get(color) + column + 1

    final_color = min(appended_elements_num, key = appended_elements_num.get)

    appended_elements = []
    for row, column in trunc_result[final_color]:
        curr_append = self.layout_copy[row][:column+1]
        appended_elements += curr_append
        for i in curr_append:
          if i[0] != final_color:
            self.color_dict[i[0]] += 1
        self.layout_copy[row] = self.layout_copy[row][column+1:]

    # print(self.color_dict)
    # print(appended_elements)
    # print('hi')

    return appended_elements + self.find_intuitive_sequence()

class Pass_In_Layout:
  '''
  This class is very similar to the previous one, except now we have a specific layout in mind
  that we want to pass into the algorithm and solve for optimal
  '''
  def __init__(self, color_lst):
    '''
    color_lst: a list of cards that we want to pass in (i.e. ['ABC', 'ABC', 'ABC])

    each entry denotes a row and the string represents cards from top of the deck to the bottom
    '''
    self.row = len(color_lst)
    self.column = len(color_lst[0])
    self.pass_in = color_lst
    self.layout = self.generate_layout()
    self.layout_copy = self.layout.copy()
    self.color_dict = dict()
    for color in self.colors:
      self.color_dict[color] = 0
    self.intuitive_sequence = self.find_intuitive_sequence()
    self.intuitive_max_length = self.max_deck_length(self.intuitive_sequence.copy())

  def generate_layout(self):
    final_ans = list()
    temp_dict = dict()
    for row in self.pass_in:
      temp_ans = []
      while len(row) != 0:
        if row[0] not in temp_dict.keys():
          temp_dict[row[0]] = 0
        temp_ans += [[row[0], str(temp_dict.get(row[0]))]]
        temp_dict[row[0]] += 1
        row = row[1:]
      final_ans += [temp_ans]
    self.colors = list(temp_dict.keys())
    return final_ans

  # the maximum number of deck length happening in the entire drawing process
  def max_deck_length(self, drawing):
    return max(self.deck_length(drawing))


  # a list consisting of the deck length after each card draw for one sequence of drawing
  def deck_length(self, one_drawing):
    curr_length = 0
    deck_length_list = []
    deck = []
    for card in one_drawing:
      if self.no_elimination(deck, card):
        deck += card
        curr_length += 1
      else:
        deck = self.shorten_deck(deck, card)
        curr_length -= 2
      deck_length_list.append(curr_length)
    return deck_length_list


  # a boolean value to judge if elimination would happen
  def no_elimination(self, deck, card):
    card_types = [i[0] for i in deck] + [card[0]]
    x = Counter(card_types)
    return all([i < 3 for i in x.values()])

  # shorten the deck size if card has the same color as two cards in the deck
  def shorten_deck(self, deck, card):
    card_types = [i[0] for i in deck] + [card[0]]
    x = Counter(card_types)
    for i in x.items():
      if i[1] == 3:
        alphabet = i[0]
    deck = [i for i in deck if i[0] != alphabet]
    return deck




  def generate_mdp(self):

    # keep track of colors of cards on the deck in a dictionary
    color_dict = dict()
    for color in self.colors:
      color_dict[color] = 0

    # keep track of current length of the deck
    current_deck_length = 0

    # keep track of maximum_length from the beginning
    maximum_deck_length = 0

    return Layout(self.layout, color_dict, current_deck_length, maximum_deck_length)


  def all_drawing_possibilities_alternative(self):
    '''
    layout: the layout return by generate_layout function, contain a list of list
    '''
    assert self.row * self.column <= 12 # does not work for big layout

    layout = self.layout.copy()
    layout = [i for i in layout if len(i) != 0]
    if not layout:
      return [[]]
    result = []
    for i in np.arange(len(layout)):
      new_layout = layout.copy()
      first = [new_layout[i][0]]
      new_layout[i] = new_layout[i][1:]
      result += [first + j for j in self.all_drawing_possibilities()]
    return result

  def find_layout_dictionary(self):
    '''
    return the dictionary containing the position of elements
    '''
    layout = self.layout.copy()
    draw_dict = {}
    for i in range(len(layout[0])):
      for j in range(len(layout)):
        letter = layout[j][i][0]
        if layout[j][i][0] not in draw_dict.keys():
          draw_dict[letter] = [[j, i]]
        else:
          draw_dict[letter].append([j, i])
    return draw_dict


  def find_intuitive_sequence(self):

    if all(inner_lst == [] for inner_lst in self.layout_copy):
      return []

    simulation_color_dict = dict()
    for color in self.colors:
      simulation_color_dict[color] = []
    position_dict = dict()
    for color in self.colors:
      position_dict[color] = []

    for j in np.arange(self.column):
      curr_color_dict = dict()
      for color in self.colors:
        curr_color_dict[color] = 0
      for i in np.arange(self.row):
        try:
          curr_color = self.layout_copy[i][j][0]
        except:
          continue
        curr_color_dict[curr_color] += 1
        position_dict[curr_color] += [[i, j]]
      for color in self.colors:
        simulation_color_dict[color] += [curr_color_dict[color]]


    # positional_idx = 0
    # summation_dict = self.color_dict.copy()
    # color_lst = []
    # while True:
    #   for color in self.colors:
    #     summation_dict[color] += simulation_color_dict[color][positional_idx]
    #     if summation_dict[color] >= 3:
    #       color_lst += color


    trunc_result = {}

    for color in self.colors:
      result = []
      position = position_dict[color][:3]
      position.sort()
      current_first_elem = None
      current_max_second_elem = None
      for pair in position:
          first_elem, second_elem = pair
          if current_first_elem is None:
              current_first_elem = first_elem
              current_max_second_elem = second_elem
          elif first_elem == current_first_elem:
              current_max_second_elem = max(current_max_second_elem, second_elem)
          else:
              result.append([current_first_elem, current_max_second_elem])
              current_first_elem = first_elem
              current_max_second_elem = second_elem

      # Add the last pair to the result
      result.append([current_first_elem, current_max_second_elem])
      if current_first_elem != None:
        trunc_result[color] = result

    # print(trunc_result)
    appended_elements_num = {}
    for color in trunc_result.keys():
      appended_elements_num[color] = 0
      for row, column in trunc_result[color]:
        # print(appended_elements_num.get(color))
        appended_elements_num[color] = appended_elements_num.get(color) + column + 1

    final_color = min(appended_elements_num, key = appended_elements_num.get)

    appended_elements = []
    for row, column in trunc_result[final_color]:
        curr_append = self.layout_copy[row][:column+1]
        appended_elements += curr_append
        for i in curr_append:
          if i[0] != final_color:
            self.color_dict[i[0]] += 1
        self.layout_copy[row] = self.layout_copy[row][column+1:]

    # print(self.color_dict)
    # print(appended_elements)
    # print('hi')

    return appended_elements + self.find_intuitive_sequence()

import itertools

class Layout:

  '''
  This class mainly deals with the set up of MDP function,
  which involves (1) generating all the states, (2) calculating the next state based on current state and an action,
  (3) finding possible actions given a specific state, (4) Determing if a state is terminal state, (5) setting up the reward between two specific states
  (6) MOST IMPORTANTLY, finding the optimal policy for a given state, and subsequently finding the optimal drawing sequence for one specific layout
  '''

  def __init__(self, layout, color_dict, length, max_length):
    self.layout = layout
    self.row = len(self.layout)
    self.column = len(self.layout[0])
    self.color_dict = color_dict
    self.deck_length = length
    self.deck_max_length = max_length
    self.states = self.generate_all_states()
    self.policies = self.generate_optimal_policies()

  def generate_next_state(self, state, row_num):


    layout = state[0]
    color_dict = state[1]
    length = state[2]
    max_length = state[3]

    new_layout = layout.copy()
    new_layout[row_num] = new_layout[row_num][1:]
    curr_card_color = layout[row_num][0][0]

    color_dict = color_dict.copy()
    color_dict[curr_card_color] += 1

    if color_dict[curr_card_color] == 3:
      deck_length = length - 2
      color_dict[curr_card_color] = 0

    else:
      deck_length = length + 1


    if deck_length > max_length:
      deck_max_length = deck_length
    else:
      deck_max_length = max_length

    return [new_layout, color_dict, deck_length, deck_max_length]

  def calculate_reward(self, state, new_state):

    if new_state[2] > state[3]:
      return -1
    return 0

  def is_terminal_state(self, state):
    return all([i == [] for i in state[0]])

  def find_possible_actions(self, state):
    return [i for i in range(self.row) if len(state[0][i]) != 0]


  def generate_all_states(self):

    states = []
    n = list(np.arange(self.column + 1))
    enumeration = [n] * self.row

    combinations = list(itertools.product(*enumeration))

    for combination in combinations:
      # print("hi")
      layout_copy = self.layout.copy()
      temp_color_dict = self.color_dict.copy()
      # print("hi")
      for i in range(self.row):

        take_out = layout_copy[i][:combination[i]]
        try:
          for card in take_out:
            temp_color_dict[card[0]] += 1
            if temp_color_dict[card[0]] == 3:
              temp_color_dict[card[0]] = 0
        except:
          continue
        layout_copy[i] = layout_copy[i][combination[i]:]

      # print("hi")
      curr_len = sum(list(temp_color_dict.values()))
      for length in np.arange(min(sum(combination) + 1, 2 * len(self.color_dict.keys()) + 2)):
        states += [[layout_copy, temp_color_dict, curr_len, length]]

    return states



  def generate_optimal_policies(self):

    discount_factor = 0.95 # Hyper-parameter which could be tuned

    # Initialize the value function to zero
    value_function = {state: 0 for state in np.arange(len(self.states))}

    # Define the Bellman backup operation
    def bellman_backup(state, value_function):
        if self.is_terminal_state(state):
          return 0
        q_values = []
        # print(self.find_possible_actions(state))
        for action in self.find_possible_actions(state):
            next_state = self.generate_next_state(state, action)
            layout = next_state[0]
            length = next_state[2]
            max_length = next_state[3]
            reward = self.calculate_reward(state, next_state)
            if not self.is_terminal_state(next_state):
                q_value = reward + discount_factor * value_function[self.states.index(next_state)]
            else:
                q_value = reward
            q_values += [q_value]
        return max(q_values)


    # Iterate until convergence
    epsilon = 0.01 # Hyper-parameter which could be tuned
    while True:
        delta = 0
        for state in self.states:
            old_value = value_function[self.states.index(state)]
            new_value = bellman_backup(state, value_function)
            value_function[self.states.index(state)] = new_value
            delta = max(delta, abs(new_value - old_value))
        if delta < epsilon:
            break

    # Derive the optimal policy from the value function
    policy = {}
    for state in self.states:
        if self.is_terminal_state(state):
          policy[self.states.index(state)] = -1
          continue
        q_values = []
        for action in self.find_possible_actions(state):
            next_state = self.generate_next_state(state, action)
            q_value = 0
            layout = next_state[0]
            length = next_state[2]
            max_length = next_state[3]
            reward = self.calculate_reward(state, next_state)
            if not self.is_terminal_state(next_state):
                q_value = reward + discount_factor * value_function[self.states.index(next_state)]
            else:
                q_value = reward
            q_values += [q_value]
        best_action = self.find_possible_actions(state)[np.argmax(q_values)]
        policy[self.states.index(state)] = best_action

    return policy

  def find_optimal_drawing_sequence(self):
    cards = []
    layout_copy = self.layout.copy()
    temp_state = [self.layout, self.color_dict, 0, 0]
    while not self.is_terminal_state(temp_state):
      action = self.policies[self.states.index(temp_state)]
      card = layout_copy[action][0]
      layout_copy[action] = layout_copy[action][1:]
      cards += [card]
      temp_state = self.generate_next_state(temp_state, action)
    return cards

  def find_optimal_sequence_one_state(self, layout, deck_length):
    '''
    <Input>
    layoutï¼š current layout of cards after some draws
    deck_length: current length of the deck

    <output>
    The optimal sequence of draws from current layout to finish
    '''

    cards = []
    layout_copy = layout.copy()
    for state in self.states:
      if state[0] == layout and state[3] == deck_length:
        temp_state = state
        break
    while not self.is_terminal_state(temp_state):
      action = self.policies[self.states.index(temp_state)]
      card = layout_copy[action][0]
      layout_copy[action] = layout_copy[action][1:]
      cards += [card]
      temp_state = self.generate_next_state(temp_state, action)
    return cards

  def find_most_frequent_state(self, drawing_sequences):

    '''
    This function is mostly used for data analysis
    Given some drawing sequence from out participant, we want to find the most frequent stages they reach
      during the entire drawing sequence, this can help us learn the bias
    '''

    num_reached = dict()
    for i in range(len(self.states)):
      num_reached[i] = 0

    for sequence in drawing_sequences:
      state = [self.layout, self.color_dict, 0, 0]
      for row_num in sequence:
        row_num = int(row_num)
        next_state = self.generate_next_state(state, row_num)
        num_reached[self.states.index(next_state)] += 1
        state = next_state

    num_reached_pd = pd.DataFrame(data = {'States': self.states, 'Frequencies': num_reached.values()})

    return num_reached_pd

from IPython.display import display, HTML

def pretty_print(df):
    return display( HTML( df.to_html().replace("]]","]]<br>") ) )

# A_tbl = pd.DataFrame(columns=['Layout', 'get_row', 'color_dict', 'deck_length', 'deck_max_length', 'elimination'])

A_layout = Initial_Layout(['A', 'B'], [3, 3], [3, 2]) # generate a random layout (big)
A_MDP = A_layout.generate_mdp()
# A_tbl = pd.concat([A_tbl, pd.DataFrame({'Layout': [A_MDP.layout], 'get_row': [-1], 'color_dict': [A_MDP.color_dict], 'deck_length': [A_MDP.deck_length],
#                       'deck_max_length': [A_MDP.deck_max_length], 'elimination': [A_MDP.eliminations]})])

# for i in [0, 1, 2, 0, 1, 2]: # a sequence of drawing
#   A_MDP = A_MDP.generate_next_state(i)
#   A_tbl = pd.concat([A_tbl, pd.DataFrame({'Layout': [A_MDP.layout], 'get_row': [-1], 'color_dict': [A_MDP.color_dict], 'deck_length': [A_MDP.deck_length],
#                       'deck_max_length': [A_MDP.deck_max_length], 'elimination': [A_MDP.eliminations]})])

# pretty_print(A_tbl)
# A_MDP.generate_optimal_policies()
# A_MDP.states

A_layout.layout

A_MDP.find_optimal_sequence_one_state([[['A', '1']], [['B', '2'], ['A', '2']], [['B', '1'], ['B', '0']]], 1)

A_MDP.find_most_frequent_state(["012012", "210210"])

A_MDP.states[105]

optimal = A_MDP.find_optimal_drawing_sequence()

intuitive = A_layout.intuitive_sequence

A_layout.max_deck_length(optimal)

A_layout.max_deck_length(intuitive)

B_tbl = pd.DataFrame(columns=['Layout', 'get_row', 'color_dict', 'deck_length', 'deck_max_length', 'elimination'])

B_layout = Initial_Layout(['A', 'B', 'C', 'D', 'E'], [3, 3, 6, 3, 3], [3, 6]) # generate a random layout (big)
B_MDP = B_layout.generate_mdp()
# B_tbl = pd.concat([B_tbl, pd.DataFrame({'Layout': [B_MDP.layout], 'get_row': [-1], 'color_dict': [B_MDP.color_dict], 'deck_length': [B_MDP.deck_length],
#                       'deck_max_length': [B_MDP.deck_max_length], 'elimination': [B_MDP.eliminations]})])

# B_MDP_copy = B_MDP
# for i in [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]: # a sequence of drawing
#   B_MDP_copy = B_MDP_copy.generate_next_state(i)
#   B_tbl = pd.concat([B_tbl, pd.DataFrame({'Layout': [B_MDP_copy.layout], 'get_row': [-1], 'color_dict': [B_MDP_copy.color_dict], 'deck_length': [B_MDP_copy.deck_length],
#                       'deck_max_length': [B_MDP_copy.deck_max_length], 'elimination': [B_MDP_copy.eliminations]})])

# pretty_print(B_tbl)
# B_MDP.value_iteration()

B_MDP.layout

optimal = B_MDP.find_optimal_drawing_sequence()
optimal

intuitive = B_layout.intuitive_sequence
intuitive

B_layout.max_deck_length(optimal)

B_layout.max_deck_length(intuitive)

# pd.set_option('max_colwidth', 400)


C_tbl = pd.DataFrame(columns=['Layout', 'get_row', 'color_dict', 'deck_length', 'deck_max_length', 'elimination'])

C_layout = Pass_In_Layout(['BDBACA', 'CBCBAD', 'CDBBDA', 'ACACDD']) # BAOER's implementation
C_MDP = C_layout.generate_mdp()
# C_tbl = pd.concat([C_tbl, pd.DataFrame({'Layout': [C_MDP.layout], 'get_row': [-1], 'color_dict': [C_MDP.color_dict], 'deck_length': [C_MDP.deck_length],
#                       'deck_max_length': [C_MDP.deck_max_length], 'elimination': [C_MDP.eliminations]})])

# for i in [1, 2, 3, 3, 0, 1, 2, 2, 0, 0, 1, 1, 2, 0, 1, 3, 0, 3, 1, 2, 3, 3, 0, 2]: # a sequence of drawing, intuitive in this case
#   C_MDP = C_MDP.generate_next_state(i)
#   C_tbl = pd.concat([C_tbl, pd.DataFrame({'Layout': [C_MDP.layout], 'get_row': [-1], 'color_dict': [C_MDP.color_dict], 'deck_length': [C_MDP.deck_length],
#                       'deck_max_length': [C_MDP.deck_max_length], 'elimination': [C_MDP.eliminations]})])

# pretty_print(C_tbl)
optimal = C_MDP.find_optimal_drawing_sequence()
intuitive = C_layout.find_intuitive_sequence()

C_layout.max_deck_length(optimal)

C_layout.max_deck_length(intuitive)

C_layout.intuitive_max_length

C_layout.max_deck_length([['C', '1'], ['B', '2'], ['C', '2'], ['C', '3'], ['B', '0'], ['B', '3'],
                          ['D', '0'], ['B', '1'], ['D', '2'], ['B', '4'], ['B', '5'], ['D', '3'],
                          ['A', '3'], ['A', '0'], ['A', '4'], ['C', '4'], ['A', '5'], ['C', '5'],
                          ['C', '0'], ['A', '1'], ['A', '2'], ['D', '1'], ['D', '4'], ['D', '5']]) # optimal sequence

"""Some draft code that may be useful later are stored below:"""

def deck_to_dict(deck):
  card_types = [i[0] for i in deck]
  x = Counter(card_types)
  return dict(x)

def shorten_deck(deck):
  card_types = [i[0] for i in deck]
  x = dict(Counter(card_types))
  for i in x.items():
    if i[1] >= 3:
      alphabet = i[0]
    deck = [i for i in deck if i[0] != alphabet]
    x[alphabet] -= 3
  return deck, x

# return a permutation list which pass into the layout to generate drawing sequences
def duplicate_numbers(layout): # [3, 2]
    n, m = layout[0], layout[1]
    numbers = []
    for i in range(1, n+1):
        numbers.extend([i] * m)
    unique_integers = set()

    for perm in permutations(numbers):
        num = int(''.join(map(str, perm)))
        unique_integers.add(num)

    unique_integers = sorted(unique_integers)
    return unique_integers

small_sequence = duplicate_numbers([3, 2])

def all_drawing_possibilities(layout, number_sequences):
    answer = []
    for s in number_sequences:
        layout_copy = layout.copy()
        s = str(s)
        elements = []
        for digit in s:
          digit = int(digit)
          elements.append(layout_copy[digit - 1][0])
          layout_copy[digit - 1] = layout_copy[digit - 1][1:]
        answer.append(elements)
    return answer

small_enumeration = all_drawing_possibilities(small_layout)
large_layout = generate_layout(['A', 'B', 'C', 'D', 'E'], [3, 3, 6, 3, 3], [3, 6])
large_enumeration = all_drawing_possibilities(large_layout)









# calculate the proportion of enumerations has the best performance
def best_proportion(all_drawing):
  '''
  all_drawing: the list of all enumerations of drawing possibilities
  '''

  all_max_length = list(map(max_deck_length, all_drawing))
  best_performance = min(all_max_length)
  return sum([i == best_performance for i in all_max_length]) / len(all_drawing)